## 1. 데이터 타입의 종류

자바스크립트의 데이터 타입은 **`기본형(Primitive Type)`** 과 **`참조형(Reference Type)`** 으로 나뉩니다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_core_javascript_study/assets/55135881/64ea19f2-7889-4d58-9f9d-0aeec1aa5516)

과연 어떤 기준으로 자료형들을 분리한 것일까요?

분류 기준을 이해하기 위해서는 먼저 자바스크립트가 **메모리 영역에서 데이터를 어떻게 처리하는지**를 알아야 합니다.

이를 더 쉽게 이해하기 위해 데이터 타입과 변수의 개념부터 알아보겠습니다.

<br />

## 2. 데이터 타입에 관한 배경지식

C, C++, Java와 같은 정적 타입 언어는 메모리의 낭비를 최소화하기 위해서 데이터 타입별로 메모리 영역을 미리 할당해놓습니다.

과거에는 메모리 용량이 매우 부족했기 때문입니다 🥲

하지만 **`자바스크립트`** 는 메모리 용량이 월등히 커진 상황에서 등장하였기 때문에 **`형변환을 신경쓰지 않고 메모리 공간을 넉넉하게 할당`** 합니다.

예를 들어 숫자의 경우 이 숫자가 **정수형인지, 부동소수형인지 구분하지 않고 8바이트를 확보합니다.**

<br />

> 정적 타입 언어란?
>
> 자료형을 컴파일 시에 결정하는 언어입니다. 타입 에러를 컴파일 단계에서 확인할 수 있습니다.
>
> (우리가 자주 쓰게 될 타입스크립트도 정적 타입 언어입니다!)
>
> ```c++
> int a = 4;
> ```

<br />

## 3. 변수 선언과 데이터 할당

### 3-1) 변수 선언

```javascript
var a;
```

위의 변수 선언식을 풀어쓰면 **"변할 수 있는 데이터를 만들고 이를 구분하는 식별자를 a로 한다."** 라고 할 수 있습니다.

결국 변수란 **`변경 가능한 데이터가 담길 수 있는 공간`** 이기 때문에, 이 식별자 a에 문자열을 담았다가 숫자를 담는 등의 작업을 할 수 있습니다.

<br />

이제 데이터 타입과 변수에 대한 기본 개념을 잡았기 때문에, **자바스크립트가 메모리 영역에서 데이터를 어떻게 처리하는지** 알아보도록 하겠습니다.

<br />

### 3-2) 변수 할당

```javascript
var a; // 변수 a 선언
a = 'abc'; // 변수 a에 데이터 할당
```

먼저 변수 a가 선언되었을 때 메모리에서 비어있는 공간 하나를 확보합니다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_core_javascript_study/assets/55135881/6558bfc5-3628-4af9-9827-5e9769ca14bd)

그리고 a에 'abc'라는 데이터가 할당된다면, 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해서(@1003) 그곳에 문자열 'abc'를 할당합니다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_core_javascript_study/assets/55135881/28155c3f-630c-48fb-9afc-d407789b3d44)

사실 `값`이라고 되어있는 공간에 직접 'abc'를 할당할 것 같지만 **`데이터를 저장하기 위한 별도의 공간(@5004)을 확보`** 해서 문자열을 저장합니다.

<br />

### 🧐 그렇다면 왜 굳이 새로운 주소에 값을 대입하고 참조하는 것일까요?

결론부터 말하자면 **`메모리를 효율적으로 관리하고 데이터 변환을 자유롭게`** 하기 위함입니다!

#### 1. 메모리를 효율적으로 관리

자바스크립트는 숫자형 데이터에 8바이트의 공간을 할당합니다. 만약 100개의 변수에 전부 숫자 5를 할당한다면 어떻게 될까요?

`100 * 8 = 800Bytes` 만큼의 메모리를 차지할 것입니다.

하지만 만약 5를 저장하는 데이터 영역을 만들고 그 영역을 **`참조`** 하는 방식으로 바꾼다면 어떻게 될까요?

주소 공간의 크기가 2바이트라고 한다면, `(100 * 2 + 8)Bytes` 만큼의 메모리만 차지하게 될 것입니다.

이처럼 변수 영역과 데이터 영역을 분리하면 **중복된 데이터에 대한 처리 효율이 높아집니다** 🔥

<br />

#### 2. 데이터 변환을 자유롭게

자바스크립트에서는 숫자형 데이터에 8바이트의 공간을 확보한다고 했지만, **문자열의 경우 정해진 규격이 없습니다.**

예를 들어, 영어는 1글자에 1바이트지만 한글의 경우 2바이트이기 때문에 필요한 메모리 용량도 제각각입니다.

<br />

그렇다면 만약 'abc'라는 문자열을 할당하고 'abcㄱㄴ'이라는 문자열로 **`재할당`** 하게 된다면 어떤 일이 발생할까요..? 😵

메모리의 크기를 'ㄱㄴ'이라는 문자열 크기만큼 늘려야 하지만, 뒤에 위치한 메모리에 이미 다른 데이터가 있다면 전체 메모리를 모두 뒤로 이동시켜야 할 것입니다.

이러한 문제를 해결하기 위해 자바스크립트는 **`데이터가 변경되면 무조건 새로운 공간을 만들어서 저장`** 합니다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_core_javascript_study/assets/55135881/efbb43ae-042c-4f0a-a55e-86ce06ff96ad)

<br />

## 4. 기본형 데이터와 참조형 데이터

사실 위의 개념들은 모두 지금 이 개념을 설명하기 위한 빌드업이었습니다...

자바스크립트의 데이터 타입을 기본형과 참조형으로 나누는 기준은 **`불변값이냐 아니냐`** 의 차이에 있습니다!

기본형은 불변성을 가집니다.

<br />

### 4-1) 불변값

불변값은 **`데이터 영역이 변하지 않는 값`** 입니다.

```javascript
var a = 'abc';
a = a + 'def';
```

예를 들어, 위의 예시에서는 변수 a에 'abc'를 할당했다가 뒤에 'def'를 추가하였습니다.

위에서 언급했듯 자바스크립트는 **데이터가 변경되면 무조건 새로운 공간을 만들어서 저장하기 때문에**

'abc'와 'abcdef'는 **`별개의 메모리 주소를 가진 데이터`** 가 됩니다. 따라서 저장된 값들의 메모리는 변하지 않았기 때문에 불변하다고 할 수 있습니다.

<br />

이처럼 **`데이터 영역에 한 번 저장된 값`** 은 가비지 컬렉터에게 처리되지 않는한 **`변하지 않는 것`** 이 불변값의 특징입니다.

> 기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값이며
>
> 불변성 여부는 데이터 영역에서 저장된 값이 변경될 수 있는지에 따라 결정됩니다.

<br />

### 4-2) 가변값

그렇다면 기본형 데이터가 불변값이니까 참조형은 무조건 가변값일까요?

결론부터 말씀드리면 **`객체 내부의 프로퍼티를 변경할 때만 가변값`** 이라고 할 수 있습니다.

객체 데이터 자체를 변경하고자 하면 새로운 데이터가 할당되기 때문에 기본형과 마찬가지로 기존 데이터는 변하지 않습니다. (불변성)

<br />

#### 데이터 할당 과정

먼저 참조형 데이터가 어떻게 할당되는지 과정을 살펴보겠습니다.

```javascript
var obj = {
  a: 1,
  b: 'bbb',
};
```

![image](https://github.com/prgrms-web-devcourse/FEDC5_core_javascript_study/assets/55135881/d888bfe9-ddb1-4739-9842-2d2feb6cae67)

1. 먼저 obj 변수를 담을 빈 공간 (@1002)을 확보하고 식별자를 obj으로 설정합니다.

2. obj 변수는 여러 프로퍼티로 이루어져있기 때문에 변수 영역을 따로 마련하고, **`메모리 영역은 동적으로`** 확보합니다.

3. 그 다음, @7103, @7104에 각각 a, b라는 프로퍼티 이름을 저장합니다.

4. 데이터 영역에서 새로운 공간을 확보해서 숫자 1과 'bbb'라는 값을 저장합니다.

<br />

위에서 봤던 불변값과는 어떤 차이가 있는 것 같으신가요?

참조형 데이터는 **`객체의 프로퍼티 영역이 별도로 존재`** 합니다!

<br />

#### 데이터 프로퍼티 변경

조금 더 응용해서 참조형 데이터의 프로퍼티를 변경하면 어떤 일이 일어나는지 알아보겠습니다.

```javascript
var obj = {
  a: 1,
  b: 'bbb',
};

obj.a = 2;
```

![image](https://github.com/prgrms-web-devcourse/FEDC5_core_javascript_study/assets/55135881/f2e0b1a7-be51-40be-a1e0-9671015a9721)

1. obj.a가 바라보고 있는 주소가 @5003에서 @5002로 변경되었습니다.

2. 하지만 obj의 주소는 @5001으로 동일합니다.

obj의 주소는 동일하기 때문에 새로운 객체가 만들어진 것이 아니고, **`객체의 내부 값이 변경된 것이므로 가변값`** 이라고 불리게 됩니다.

<br />

## 5. 불변 객체

객체의 데이터 자체를 변경하고자 한다면 새로운 데이터를 할당하게 되기 때문에 기존 데이터는 변하지 않습니다. (불변성)

하지만 **`내부 속성을 변경`** 하게 된다면 **`가변성`** 을 가지게 됩니다.

따라서 내부 속성을 변경할 때마다 매번 **`새로운 객체를 만들어서 재할당`** 을 한다면 **`객체도 불변성을 확보`** 할 수 있습니다.

<br />

#### 🧐 그렇다면 불변 객체가 왜 필요한 걸까요?

변경 가능한 상태를 여러 곳에서 공유하게 됨으로써 발생하는 문제들을 해결하기 위해 사용됩니다.

예를 들어, React에서는 상태가 불변해야합니다. 크게 아래의 두 가지 이유가 있습니다.

1. 값이 변경됐는지 알기 위해서
2. 원본 값을 수정하면 이전 상태과 변경된 상태값이 동일해져서 비교할 수 없기 때문에

React에서는 상태가 변하면 컴포넌트가 다시 렌더링 됩니다.

하지만 상태가 불변하지 않다면 객체의 변화를 감지할 수 없기 때문에 개발자가 원하는 시점에 렌더링을 하기 어렵습니다.

따라서 우리는 불변 객체를 사용하여 상태를 관리하게 됩니다!

<br />

#### 😌 불변 객체를 만드는 법

내부 프로퍼티를 변경할 때마다 새로운 객체를 만들어서 재할당한다면 불변성을 확보할 수 있습니다.

그 방법으로는 객체를 복사하는 방법들이 있습니다.

- 얕은 복사
  - 원본이 바뀌면 사본도 변경되고, 사본이 변경되면 원본도 변경되는 복사 방법
  - 데이터가 생성되는 것이 아니고 데이터의 참조값을 전달되기 때문에 데이터를 공유하게 됩니다.
  <br />

  ```javascript
  var copyObj = function (target) {
	var result = {};
    for (var prop in target) {
    	result[prop] = target[prop]
    }
    return result;
  }
  ```  

- 깊은 복사
  - 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법
  - 원본과 사본이 완전히 다른 객체를 참조하기 때문에 어느쪽의 프로퍼티를 변경해도 **`다른 쪽에 영향을 주지 않습니다.`**
  <br />

  ```javascript
  var copyObjectDeep = function(target) {
  	var result = {};
  	if (typeof target === 'object' && target !== null) {
  		for (var prop in target) {
  			result[prop] = copyObjectDeep(target[prop]);
  		}
  	} else {
  		result = target;
  	}
  	return result;
  }
  ```


<br />


## 6. undefined와 null

둘의 공통점은 **`값이 비어있는 상태`** 라는 것입니다.

그렇다면 왜 두 가지로 구분해서 사용할까요?

### null

null은 개발자가 **`'비어있음'을 명시적으로`** 나타내고 싶을 때 사용합니다.

그 외에도 **`사용하지 않는 변수를 메모리에서 제거`** 할 때 null을 할당하는 상황에서 사용됩니다.

<br />

주의해야할 점은 typeof null은 자바스크립트 자체 버그로 object라고 반환되기 때문에

**`null 여부를 체크할 때는 일치 연산자(===)`** 를 사용해주어야 합니다.

```javascript

var n = null;
console.log(typeof n); // object

console.log(n === undefined);  // false
console.log(n === null);  // true

```

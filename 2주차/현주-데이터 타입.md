## 1. 데이터 타입의 종류

![data_type](https://velog.velcdn.com/images/mooongs/post/d87af8ea-289b-4661-a7f7-1280fc5a44a2/image.png)

- 자바스크립트의 데이터 타입은 크게 **기본형**(**primitive type**)과 **참조형**(**reference type**)이 있다.
- 기본형은 `불변성`을 가진다.
  
  ```javascript
  var a = 10;
  a = 15;
  ```
  + 변하지 않는다는 것은 어떤 의미? [불변값](#4-1-불변값)
  + 10이 15로 바뀌는 게 아님!

<br />

 ## 2. 데이터 타입에 관한 배경 지식

 - 1 bit = 0 또는 1로만 표현할 수 있는 메모리 단위
 - 1 byte = 8 bit (편의를 위해 8비트를 묶은 단위가 1바이트)

![data_type_memory](https://velog.velcdn.com/images%2Fdonghoim%2Fpost%2F6b0597c1-c49e-44d0-aa82-2067264ef517%2Fimage.png)

- 정적 타입 언어(C, C++, JAVA)는 **메모리 낭비를 줄이기 위해** 데이터 타입 별로 할당되는 메모리가 다르다.
  - 정적 언어란?
    - C, C#, C++, Java
    - ‘타입(자료형)’을 **컴파일(Compile)** 시에 결정하는 언어.
    - 미리 타입을 결정하므로 속도가 빠르고, 타입 에러를 초기에 발견 가능하여 Run Time 오류 방지, 타입의 안정성이 높다.
  - 동적 언어란?
    - JavaScript, Ruby, Python
    - ‘타입(자료형)’을 **실행(Run Time)** 시에 결정하는 언어.
    - 자동으로 타입을 판단해주므로 편리할 수 있으나, 실행 중 예상 못한 타입 에러가 발생할 수 있다.

- 자바스크립트는 이후 메모리 용량이 커졌을 때 등장했기에, 타입별로 **메모리를 넉넉하게 할당**한다.
  - Number형에는 64bit(8bytes).
  - 문자열은 가변적이므로 특별한 규격은 없다. (한 글자 당 영어 1 byte, 한글 2 byte)
 
<br />

## 3. 변수 선언과 데이터 할당

  - 변수 선언 : `var a;`

   |주소|1002번지|1003번지|...|
   |---|---|---|---|
   |데이터| |이름 : a <br> 값 : |...|

  1. 컴퓨터는 메모리에서 비어있는 공간 중 하나인 **1003번지**를 확보하여, 이 공간의 이름을 a라고 지정한다.

  - 데이터 할당 : `a = 'abc';` <br>

  `변수 영역`

  |주소|1002번지|**1003번지**|1004번지|
  |---|---|---|---|
  |데이터| |이름 : a <br> 값 : @5004 |...|

  `데이터 영역`
  
  |주소|5002번지|5003번지|5004번지|
  |---|---|---|---|
  |데이터| | |'abc'|

  1. `데이터 영역` 의 빈 공간인 **5004번지**에 문자열 ‘abc’를 저장한다.
  2. `변수 영역` 에서 a라는 식별자(이름) 검색했더니 **1003번지**가 나왔다.
  3. 아까 문자열을 저장한 **5004번지** 주소를 **1003번지**에 저장한다.


  #### 왜 변수 영역에 직접 ‘abc’를 안넣고 5004번지 주소를 넣을까?
  
  > 미리 확보한 공간 내에서만 데이터 변환을 해야한다면 공간을 더 늘려야한다. <br />
  > 만약 중간에 있는 데이터 공간을 늘려야하면? 뒤에 있는 데이터들을 더 뒤로 옮기고, 다시 그 주소들 연결 시키고.. 복잡하다.  <br />
  > → 효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 저장해야 한다. <br />
  
<br />

## 4. 기본형 데이터와 참조형 데이터

### 4-1. 불변값

- 기본형 데이터는 모두 불변값이다.
- 변수와 상수의 차이는 ‘변경 가능성’ (변수 영역)
- 불변성 여부의 ‘변경 가능성’은 **데이터 영역**이 대상이다.

```javascript
01 var b = 5;
02 var c = 5;
03 b = 7;
```

**01** 컴퓨터는 데이터 영역에서 5를 찾고, 없으면 데이터 공간을 하나 만들어 5를 저장하고 그 주소를 b에 저장한다.

**02** 컴퓨터는 데이터 영역에서 5를 찾고, 있으면 그 주소를 c에 저장한다.

**03** 컴퓨터는 데이터 영역에서 7을 찾고, 없으면 데이터 공간을 하나 만들어 7를 저장하고 그 주소를 b에 저장한다.

**→ 데이터 영역의 5와 7은 모두 다른 값으로 변경할 수 없다.**

**→ `불변성`**

변경은 새로 만드는 동작을 통해서만 이루어진다!

<br />

---

<br />

### 4-2.가변값

- 참조형 데이터의 기본적인 성질은 가변값이지만 불변값으로 활용하기도 가능하다.

```javascript
var obj = {
	a : 1,
	b : 'bbb'
}
```

  `변수 영역`

  |주소|1002번지|1003번지|1004번지|...|
  |---|---|---|---|---|
  |데이터| |이름 : obj <br> 값 : @5002 | | |

  `데이터 영역`
  
  |주소|5002번지|5003번지|5004번지|...|
  |---|---|---|---|---|
  |데이터|@7103 ~ ?|1|'bbb'| |

  `객체 @5002의 변수 영역`

  |주소|7103번지|7104번지|7105번지|...|
  |---|---|---|---|---|
  |데이터| |이름 : a <br> 값 : @5003 | 이름 : b <br /> 값 : @5004 | |

  
  1. 컴퓨터는 `변수 영역` 에 빈 공간 **1003번지**를 확보하고, 이름을 *obj*로 지정한다.
  2. `데이터 영역` 의 **5002번지**에 *obj*의 데이터를 저장하려고 했으나, 여러 개의 프로퍼티가 존재하므로 `별도의 변수 영역` **7103번지 ~** 을 마련하고, 그 영역의 주소를 **5002번지**에 저장한다.
  3. **7103번지, 7104번지**에 *obj*의 프로퍼티 이름들(a, b)을 지정한다.
  4. `데이터 영역` 에서 *1*을 찾고, 없으므로 **5003번지**에 저장하고, 그 주소를 **7103번지**에 저장한다.
  5. `데이터 영역` 에서 *bbb*를 찾고, 없으므로 **5004번지**에 저장하고, 그 주소를 **7104번지**에 저장한다.

<br />

  #### 참조형 데이터는 객체의 프로퍼티 영역이 별도로 존재한다.
  
  > 데이터 영역에 저장된 값은 모두 불변값이지만, 변수 영역에서는 다른 값을 넣을 수 있다. <br />
  > 그렇기 때문에 참조형 데이터가 가변값이라고 하는 것이다. <br />
  > 프로퍼티 값이 바뀌어도 새로운 객체가 만들어지지 않고, 기존 객체 내부의 값이 바뀐다. <br />

<br />

  #### 만약 여기서 재할당 명령을 내린다면?
```javascript
  obj.a = 2
```
  > 컴퓨터는 `데이터 영역` 에서 *2*를 찾고, 없으므로 **5005번지**에 저장하고, 그 주소를 **7103번지**에 저장(업데이트) 한다. <br />
  > -> 변수 obj이 바라보고 있는 주소는 변하지 않고(@5001 그대로), 기존의 객체 내부 값만 바뀐다. <br />

  <br />
  
  #### 그럼 기존 5003번지에 저장된 데이터는 어떻게 될까?
  > 객체 @7103의 데이터 영역이었던 @5003은 **참조 카운트가 0이 되어 GC의 대상이 되어 사라진다.** <br />
  > - **참조 카운트** : 자신의 주소를 참조하는 변수의 개수로, 참조 카운트가 0인 메모리 주소는 가비지 컬렉터에 의해 수거되어 빈 공간이 됩니다.<br />
  > - **가비지 컬렉터(Garbage Collector, GC)** : 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박했을 때마다 자동으로 수거 대상을 수거한다.<br />

<br />

---

<br />

### 4-3.변수 복사 비교

```javascript
  var a = 10;
  var b = a;

  var obj1 = { c : 10, d : 'ddd' };
  var obj2 = obj1;

  b = 15;
  obj2.c = 20;
```


  `변수 영역`

  |주소|1001번지|1002번지|1003번지|1004번지|1005번지|
  |---|---|---|---|---|---|
  |데이터|이름 : a <br /> 값 : @5001 | 이름 : b <br /> 값 : ~~@5001~~ -> @5004 <br /> **[주소 업데이트O]**  | 이름 : obj1 <br> 값 : @5002 | 이름 : obj2 <br> 값 : @5002 <br /> **[주소 업데이트X]**| |

  `데이터 영역`
  
  |주소|5001번지|5002번지|5003번지|5004번지|5005번지|
  |---|---|---|---|---|---|
  |데이터|10|@7103 ~ ?|'ddd'|15|20|

  `객체 @5002의 변수 영역`

  |주소|7103번지|7104번지|7105번지|
  |---|---|---|---|
  |데이터|이름 : c <br> 값 : ~~@5001~~ -> @5005 <br /> **[주소 업데이트O]** | 이름 : d <br /> 값 : @5003 | |


- 복사 과정은 기본형 데이터와 참조형 데이터 모두 **같은 주소를 바라보게 되는 점**에서 동일하다.
- 그러나 **데이터 할당 과정**에서 이미 차이가 있기 때문에, **복사 이후 동작에서 큰 차이가 발생**한다.
- 기본형은 주솟값을 복사하는 과정이 한 번만 일어나지만, 참조형은 한 단계를 더 거치게 된다.

```javascript
a !== b
obj1 === obj2
```

#### 객체 자체를 변경하면 어떻게 될까?

```javascript
  var a = 10;
  var b = a;

  var obj1 = { c : 10, d : 'ddd' };
  var obj2 = obj1;

  b = 15;
  obj2.c = { c : 20, d : 'ddd' }; // 프로퍼티 변경이 아닌, 객체 자체를 변경한  다.
```

> 데이터 영역의 새로운 공간에 새 객체가 저장되고, 그 주소를 변수 영역의 obj2 위치에 저장하므로, 객체에 대한 변경임에도 값이 달라진다!
> 참조형 데이터는 '가변값'이지만, 그 때의 '가변'은 그 내부의 프로퍼티를 변경할 때만 성립된다.

<br />

## 5. 불변객체

### 얕은 복사와 깊은 복사

  - 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우가 종종 발생한다.
  - `얕은 복사` : 바로 아래 단계의 값만 복사하는 방법.
  - `깊은 복사` : 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법.
  - 객체에 **직접 속한 프로퍼티**에 대해서는 문제가 발생하지 않지만, **중첩된 객체**의 경우 **한 단계 더 들어간 내부의 프로퍼티**는 **기존 데이터를 그대로 참조**하게 되는 문제가 발생한다.
  - 따라서 객체를 복사하여 완전히 새로운 데이터를 만들어야 할 때(불변객체)에는, 객체의 프로퍼티 중 **기본형 데이터는 그대로 복사**, **참조형 데이터는 다시 그 내부의 프로퍼티를 복사**해야한다.


#### 객체의 깊은 복사를 수행하는 함수
```javascript
  var copyObjectDeep = function(target) {
    var result = {};
    //객체인 경우, 내부 프로퍼티를 순회하도록 재귀
    if (typeof target === 'object' && target !== null) {
      for (var prop in target) {
        result[prop] = copyObjectDeep(target[prop]);
      }
    }
    //객체가 아닌경우, target적용(복사)
    else {
      result = target;
    }
    return result;
  }
```

> 깊은 복사로 객체를 복사한 경우, 어떤 프로퍼티를 변경하더라도 원본과 사본은 서로 영향을 주지 않는다. <br />

#### 간단하게 깊은 복사 하는 방법 ?

```javascript
  var copyObjectViaJSON = function(target) {
    return JSON.parse(JSON.stringify(target));
  }
```

> 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JOSN 객체로 바꾸기! <br />
> httpRequest로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋다.

<br />

## 6. undefined 와 null

- 둘 다 `없음`을 나타낸다.
- `undefined`는 사용자가 명시적으로 지정할 수도 있지만, 자바스크립트 엔진이 자동으로 부여하는 경우도 있다.
> 1. 값을 대입하지 않은 변수(데이터 영역의 메모리 주소를 지정하지 않은 식별자)에 접근할 때
> 2. 객체 내부의 존재하지 않는 프로퍼티에 접근할 때
> 3. return 문이 없거나 호출되지 않는 함수의 실행 결과
 
#### 그럼 명시적으로 지정한건지 자동으로 부여된건지 어떻게 구분하죠?

- 비어있음을 명시적으로 나타내고 싶을 때는 `undefined`가 아닌 `null`을 사용하는 것을 권장한다!
- `undefined`는 **자바스크립트 엔진이 반환**해주는 값, `null`은 **사용자가 명시적으로 비어있음**을 나타내는 값.
  
#### null 주의할 점
- `typeof null === object` << 자바스크립트의 자체 버그
- `===`를 사용해야 null과 undefined를 정확히 판별할 수 있다.
- `==`은 `null == undefined`로 판단하므로 사용x

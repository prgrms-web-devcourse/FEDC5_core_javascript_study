## 접근 권한 제어(정보 은닉)

정보 은닉은 코드가 외부에 노출되는걸 막고 각각의 코드간에 결합도를 낮춰주어서 프로그래밍의 유연성을 높이는 중요한 개념입니다. 다만 자바스크립트에는 public이나 private 같은 접근 권한을 직접 부여하는 수단이 없습니다. 

그래서 필요한 것이 바로 클로저입니다. 클로저가 참조하고 있는 외부 함수의 환경은 클로저만을 통해서 접근할 수 있기 때문입니다. 우리는 이것을 활용해 정보를 격리하는 동시에 원하는 값을 받아올 수 있습니다.

### 자바스크립트에서 private한 값 구현하기

```js
var outer = function() {
	var a = 1;
	var inner = function() {
		return ++a;
	};
	return inner;
};

var outer2 = outer();
console.log(outer2());    // 2
console.log(outer2());    // 3
```

자바스크립트는 기본적으로 함수 레벨 스코프를 따르죠. 그 말인 즉슨 지금 이 outer 함수는 외부로부터 완전히 격리된 상태라고 볼 수 있습니다. var로 a를 선언해도 외부에서는 a에 접근할 수 없습니다. 

그런데 outer 함수가 반환하고있는 inner 함수는 다시 a를 하나 증가시킨 값을 반환합니다. a라는 변수를 외부에서 개입할 여지를 주지 않고 inner라는 클로저를 통해서만 a에서 하나씩 증가된 값을 반환합니다.

이러한 클로저의 부수효과는 개발자의 휴먼에러를 방지함과 동시에 a라는 변수를 다른곳에서 얼마든지 선언해도 중복되지 않는 유연함을 가집니다.



비교하기 쉽게 차이점을 보여드리자면,
```js
const obj = {      // 객체
	a: 2;
	b: 1;
	add: function() {
		console.log(a + b);
	}
	minus: function() {
		sonsole.log(a - b);
	}
}

function calculator() {       // 함수
	var a = 2; 
	var b = 1;
	return {
		a: a,
		b: b,
	};
}
```

이렇게 a, b를 저장하는 obj라는 객체와 a, b를 변수로 선언하는 calculator 함수가 있습니다. 여기서 obj의 add 메소드와 calculator 함수의 반환값 add의 출력값은 동일하지만 obj의 a와 b는 접근과 변경이 가능하기 때문에 데이터의 위변조 가능성이 있습니다.

```js
obj.add();   // 3
obj.minus();  // 1
calculator().add()   // 3
calculator().minus()   // 1

obj.a = 1000;
obj.b = 2000;
calculator().a = 1000;
calculator().b = 2000;

obj.add();   // 3000
obj.minus();  // -1000
calculator().add()   // 3
calculator().minus()   // 1
```

정리하자면
1. 자바스크립트는 클로저를 통해 private한 값을 만들 수 있습니다.
2. 외부에 접근권한을 주고자 한다면 참조형 데이터를, 그렇지 않다면 클로저로 private 값을 리턴해 주면 됩니다.


## 부분 적용 함수

부분 적용 함수는 미리 인자를 받아두고 이후 재차 받게되는 인자들로 최종적으로 실행하게되는 함수입니다.

이 과정을 의사 코드로 구현하자면,
```
1차적으로 인자를 담을 함수 {

	인자를 담아서 이후 호출될 클로저에 bind
	
	return 이미 담겨있는 인수들과 2차적으로 담긴 인자들로 결과 출력하는 클로저
}
```

![[클로저의 활용 사례.png]]

위 부분 적용 함수 partial에서 1차적으로 받게되는 인자들을 저장하고 이후 호출되는 클로저에서 나머지 인자를 받아 실행됩니다.

정리하자면
![[클로저의 활용 사례-1.png]]

이 부분이 1차적인 인수 저장 부분이 되고

![[클로저의 활용 사례-2.png]]

이 클로저를 통해 2차적으로 전달받은 인수들까지 합쳐서 실행이 됩니다.

![[클로저의 활용 사례-3.png]]


#### 디바운스

디바운스란 짧은 시간 동안 많은 이벤트가 발생 했을때 처음과 끝의 이벤트만 처리하는 것으로, 부분 적용 함수의 대표적인 케이스입니다. 

![[클로저의 활용 사례-8.png]]
![[클로저의 활용 사례-9.png]]




## 커링 함수

커링함수는 부분 적용 함수와 다르게 함수가 하나의 인자만을 받고 마지막 인자를 받기 전까지 각 함수는 대기하게 됩니다. (블록킹과는 다릅니다)

![[클로저의 활용 사례-4.png]]

위 커링 함수에서 인자를 5개를 받고 나서 실행하는 것을 볼 수 있습니다. 하지만 가독성이 너무 떨어지기 때문에 다음과 같이 화살표함수를 이용하여 한 줄로 구현할 수 있습니다.

![[클로저의 활용 사례-5.png]]


커링함수는 여러가지 값들을 순차적으로 받아야될 때 유용하게 쓰입니다. 책의 예시와 같이 fetch 함수를 통해 api 요청을 보내려면 baseUrl과 경로, id 값이 포함되어야 합니다. 

![[클로저의 활용 사례-6.png]]

그럼 왜 굳이 baseUrl, path, id를 한꺼번에 받지 않고 순차적으로 받으려고 할까요?

1. **함수 재사용**: 커링을 사용하면 특정 인자들이 고정된 새로운 함수를 만들어 낼 수 있습니다. 이렇게 만들어진 새로운 함수는 다른 부분에서 재사용이 가능합니다.
    
2. **유연한 함수 호출**: 모든 인자를 한 번에 제공하지 않고, 필요한 시점에 필요한 만큼의 인자만 제공하여 함수를 실행할 수 있습니다.
    
3. **함수 조합(function composition)**: 커링을 사용하면 여러 개의 단일 인자 함수들을 조합하여 복잡한 로직을 구현할 수 있습니다.

```js
function multiply(a) {
    return (b) => {
        return a * b;
    }
}

const double = multiply(2);
console.log(double(5)); // 10

```

multiply 함수는 a 인자를 받고 b를 안자로 받아서 a와 b를 곱한 값을 리턴하는 함수를 반환합니다. 쉽게 말해 원하는 만큼 곱해주는 것이죠.

`const double = multiply(2)` 에서 보신것과 같이
`const triple = multiply(3)` 과 같이 할당할 수도 있습니다.

그러면 재사용 측면에서도, 함수의 조합으로도 굉장히 직관적이고 효율적인 코드를 구현할 수 있습니다.


## 정리
1. 클로저란 외부 함수의 실행컨텍스트가 종료된 후에도 내부 함수가 참조중이라면 내부 함수가 참조중인 외부 함수의 변수들은 사라지지 않는 현상입니다.
2. 내부 함수를 외부로 전달하는 방법에는 return하는 경우와 콜백을 활용하는 경우가 있습니다.
3. 클로저는 메모리를 유념하면서 관리해야됩니다.


## 클로저

- **함수형 프로그래밍 언어**에서 등장하는 보편적인 특성으로, 자바스크립트만의 특성은 아니다.
```
📌 함수를 선언할 때 만들어진 유효범위가 사라진 후에도 호출할 수 있는 함수?
📌 이미 생명주기 상 끝난 외부 함수의 변수를 참조하는 함수?
📌 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상?
```
이외에도 다양한 정의가 존재한다. 

> 함수가 선언될 당시의 lexical environment가 뭘까?

### 이쯤에서 다시 복습해보는 실행 컨택스트...

 ![excution_context](https://velog.velcdn.com/images%2Fkich555%2Fpost%2F78521081-cec0-49ec-ae1c-8f28ce358633%2Fexecutioncontext.png)

- `Lexical Environment` : 현재 컨텍스트 내부의 식별자, 외부 환경를 참조하는 포인터 등의 환경 정보들
- `Environment Record` : 내부 식별자 (매개변수, 선언된 함수, 선언된 변수)
- `Outer Environment` : 외부 Lexical Environment을 참조하는 포인터. scope chain을 위해 존재.
  - scope chain : 내부 식별자의 유효범위를 안에서부터 바깥으로 차례대로 검색
- 스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 결정된다


=> 함수가 선언될 당시의 lexical enviroment란, outer environment를 의미한다.
```jsx
function A() {
  ...
  var i;
  function B() { ... }
}
```

- 함수B는 자신이 선언될 당시의 lexical enviroment, 즉 함수A의 lexical environment을 기억한다.
- (= 함수B의 outer 포인터가 A의 l.e를 가르킨다.)
- 함수 B는 함수A에 선언한 변수에 접근 가능하다. ( A에서 B는 불가능)

```
📌 클로저 : 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상
```
> ex) [함수B] <-> [함수A의 l.e] 

#### 상호 관계?
- 함수 B가 언제나 함수 A의 l.e를 사용하진 않음. 왜?
- 함수 B에서 함수 A 내부의 변수를 참조하지 않는 경우 필요없음.
- **즉, 내부 함수에서 외부 변수를 참조하는 경우에 한해서만 상호 관계가 의미 있다.**

```
클로저는 어떤 함수에서 선언한 변수를 참조하는 내부 함수에서만 발생하는 현상
```
> ex) 함수B에서, 함수A에서 선언한 변수i를 참조하는 경우, 발생하는 현상 => 클로저

#### 내부 함수에서 외부 변수를 참조하는 경우는 어떤 상황일까?

```jsx
var outer = function() { //외부 함수
  var a=1; //외부 변수
  var inner = function(){ //내부 함수
    console.log(++a); //2
  };
  inner();
};
outer(); 
```
- `console.log(++a)` 가 실행될 때, inner 함수 내부에는 선언된 a가 없다.
- inner함수의 environment record에서 값을 못 찾았으므로, inner함수의 outer environment 포인터가 가리키는 `outer함수의 l.e` 에 접근해서 a를 찾는다.
- a를 찾았으므로 2를 출력한다.
- outer() 실행이 모두 종료되면, 실행 컨텍스트가 종료되므로 l.e에 저장된 식별자 a, inner에 대한 참조가 지워진다.
- 참조하는 변수가 사라지므로 GC의 수거 대상이 된다.

#### 조금 내용을 바꿔서, 내부 함수 자체를 반환해 실행하면 어떻게 될까?

```jsx
var outer = function() { //외부 함수
  var a=1; //외부 변수
  var inner = function(){ //내부 함수
    return ++a;
  };
  return inner; // 내부 함수 자체를 반환
};
var outer2 = outer(); // outer2 = inner;
console.log(outer2()) //inner() 실행 => 2
console.log(outer2()) //inner() 실행 => 3
```

- inner함수가 실행되며, outer environment 포인터를 쫓아가며 2, 3이 차례대로 출력된다.
- 이때, outer2함수(=inner함수)가 실행될 때는 이미 outer함수의 실행 컨텍스트가 종료된 상태이다.
- 근데 어떻게 outer함수의 l.e에 접근할 수 있을까?

#### 가비지컬렉터의 동작 방식 때문이다!

- GC는 값을 참조하는 변수가 하나라도 있다면, 수집 대상에서 제외한다.
- inner함수는 언젠가 outer2를 실행하여 호출될 가능성이 있다.
- 언젠가 inner 함수의 실행 컨텍스트가 활성화되면, inner함수의 outer environment 포인터가 outer함수의 l.e를 필요로하므로(가리키므로) 수집대상에서 제외한다.
- 함수의 실행 컨텍스트가 종료되어도 l.e가 GC 수집 대상에서 제외되는 경우
  - 지역 변수를 참조하는 내부함수가 외부로 전달 된 경우!
 
```
클로저란, 함수 A에서 선언한 변수i를 참조하는 함수B를 외부로 전달한 경우,
함수A의 실행컨텍스트가 종료된 이후에도 변수 i가 사라지지 않는 현상이다.
```

#### 외부로의 전달은 return말고 콜백함수도 존재한다

## 클로저와 메모리 관리

- GC의 수거대상이 되지 않도록 개발자가 의도적으로 설계해버린다면? 누수 발생...
- 클로저는 필요한 지역변수가 메모리를 소모하게 한다. => 필요가 없어지면 메모리를 소모 안하게 하면 된다.
- 참조 카운터를 0으로 만들면 GC가 수거해간다. 식별자에 참조형이아닌 기본형(null, undefined)을 할당한다.

```jsx
var outer = function() { //외부 함수
  var a=1; //외부 변수
  var inner = function(){ //내부 함수
    return ++a;
  };
  return inner; // 내부 함수 자체를 반환
};
var outer2 = outer(); // outer2 = inner;
console.log(outer2()) //inner() 실행 => 2
console.log(outer2()) //inner() 실행 => 3

outer2 = null; //outer2식별자의 inner 함수 참조를 끊는다.
```

## 클로저 활용 사례 - 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때

